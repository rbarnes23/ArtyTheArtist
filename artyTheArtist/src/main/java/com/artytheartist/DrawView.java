package com.artytheartist;

import java.io.ByteArrayOutputStream;
import java.io.File;
import java.io.FileInputStream;
import java.io.FileOutputStream;
import java.io.IOException;
import java.util.HashSet;
import java.util.Timer;
import java.util.TimerTask;
import java.util.Vector;

import org.json.JSONArray;
import org.json.JSONException;
import org.json.JSONObject;

import com.tokenlibrary.Token;

//import android.annotation.SuppressLint;
import android.content.Context;
import android.content.res.AssetManager;
import android.graphics.Bitmap;
import android.graphics.BitmapFactory;
import android.graphics.BlurMaskFilter;
import android.graphics.Canvas;
import android.graphics.Color;
import android.graphics.EmbossMaskFilter;
import android.graphics.MaskFilter;
import android.graphics.Paint;
import android.graphics.Path;
import android.graphics.PorterDuff;
import android.graphics.PorterDuffXfermode;
import android.graphics.Rect;
//import android.graphics.RectF;
import android.graphics.Typeface;
import android.graphics.drawable.BitmapDrawable;
//import android.hardware.Camera;
//import android.opengl.GLSurfaceView;
import android.os.Build;
import android.os.Environment;
import android.os.Handler;
import android.text.Layout;
import android.text.StaticLayout;
import android.text.TextPaint;
import android.util.AttributeSet;
import android.view.MotionEvent;
import android.view.SurfaceView;
import android.view.View;
import android.view.ViewGroup;
import android.view.View.OnTouchListener;
import android.view.inputmethod.InputMethodManager;
import android.widget.EditText;

//@SuppressLint("NewApi")
public class DrawView extends SurfaceView implements OnTouchListener {
	Paint paint = new Paint();
	Path mPath = new Path();
	private Context mContext;
	Base64 mBase64 = new Base64();
	private Canvas mCanvas;
	private float mX, mY;
	private static final float TOUCH_TOLERANCE = 4;
	private static final int IMAGE_MAX_SIZE = 450;
	private static final int SUCCESS = 1;
	private Bitmap mBitmap;
	private Paint mBitmapPaint;
	private Paint mPaint;
	private MaskFilter mMaskFilter = null;
	private MaskFilter mEmboss;
	private MaskFilter mBlur;
	private MaskFilter mGlow;
	private int mBackGroundColor = Color.WHITE;
	private String mBackGroundString = "";
	private JSONArray jArray;
	private Vector<JSONArray> jArrayList = new Vector<JSONArray>();
	private int mNumberMove = 0;
	private int mNewArrayListSize = 1;
	private String mMemberid = AppSettings.getMemberid(MainActivity
			.getContext());
	private boolean mNetworkOn = AppSettings.getNetworkStatus();
	private int mPaintColor = Color.BLUE;
	private float mScaleW, mScaleH = 1;
	private float mSW = AppSettings.getBrushWidth(MainActivity.getContext());
	private int mBrushOpacity;
	private int mBackgroundOpacity = 255;
	private int mEraserWidth = AppSettings.getEraserWidth(MainActivity
			.getContext());;
	private int mF = 0;
	private boolean mErase = false;
	private boolean mClr = false;
	private int mDRW = 0;
	File folder = new File(Environment.getExternalStorageDirectory()
			+ "/artytheartist");
	private BitmapDrawable mBackGround;
	// private Handler mHandler = new Handler();/*Moved to
	// MainActivity...REMOVE*/
	private boolean mRedraw = false;
	// private boolean mMsgDraw = true; // Do not send message to friends if
	// this
	// was generated by a message
	private boolean mText = false;
	private View mView;
	private String mTextString = "";
	private int mTextSize = 48;
	private Typeface mTypeface;
	private String mTypefaceString;
	AssetManager assetManager;
	private EditText mEditText;
	private InputMethodManager mImm;
	private int mAngle = 0;
	private Rect rectLogged = new Rect();
	private String mTypeFacePath = "fonts/";
	private boolean mColorSample;
	HashSet<Integer> mColorSampleList = new HashSet<Integer>();
	Bitmap mColorSampleBitmap;
	private boolean mSlideShow;
	private int mCount = 0;
	private String[] mSlides;

	// Remove camera for now
	private boolean mPause = false;
	private long mInterval;
	// private RectF rectSlideShow = new RectF();
	private Bitmap bitmapPause = BitmapFactory.decodeResource(getResources(),
			android.R.drawable.ic_media_pause);
	private Bitmap bitmapPlay = BitmapFactory.decodeResource(getResources(),
			android.R.drawable.ic_media_play);
	Timer mTimer;

	// private ViewGroup slideshowButtons;

	public DrawView(Context context, AttributeSet attrs) {
		super(context, attrs);
		mContext = context;

		setFocusable(true);
		setFocusableInTouchMode(true);
		this.setOnTouchListener(this);
		mPaint = new Paint();
		mPaint.setAntiAlias(true);
		mPaint.setDither(true);
		// mPaint.setColor(0xFFFF0000);
		mPaint.setColor(mPaintColor);
		mPaint.setStyle(Paint.Style.STROKE);
		mPaint.setStrokeJoin(Paint.Join.ROUND);
		mPaint.setStrokeCap(Paint.Cap.ROUND);
		mPaint.setStrokeWidth(mSW);
		mPaint.setAlpha(mBrushOpacity);
		mPaint.setMaskFilter(mMaskFilter);
		Bitmap bMap = BitmapFactory.decodeResource(getResources(),
				R.drawable.appicon512a);
		restorefromBitmap(bMap);
		setBackGround(mBackGroundString, false);
	}

	private MaskFilter getMaskFilter(int aMF) {
		MaskFilter maskFilter = null;
		switch (aMF) {
		case 0: // NORMAL
			maskFilter = null;
			break;
		case 1: // BLUR
			maskFilter = mBlur;
			break;
		case 2: // EMBOSS
			maskFilter = mEmboss;
			break;
		case 3: // GLOW
			maskFilter = mGlow;
			break;
		}
		return maskFilter;
	}

	public void setMaskFilter(int aType) {
		mEmboss = new EmbossMaskFilter(new float[] { 1, 1, 1 }, 0.4f, 6, 3.5f);
		mBlur = new BlurMaskFilter(8, BlurMaskFilter.Blur.NORMAL);
		mGlow = new BlurMaskFilter(5, BlurMaskFilter.Blur.OUTER);
		mF = aType;
		switch (aType) {
		case 0: // NORMAL
			mMaskFilter = null;
			break;
		case 1: // BLUR
			mMaskFilter = mBlur;
			break;
		case 2: // EMBOSS
			mMaskFilter = mEmboss;
			break;
		case 3: // GLOW
			mMaskFilter = mGlow;
			break;
		}
		mErase = false;
	}

	@Override
	protected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) {
		// maxScrollX= hz.getWidth();
		super.onMeasure(widthMeasureSpec, heightMeasureSpec);
	}

	@Override
	protected void onSizeChanged(int w, int h, int oldw, int oldh) {
		super.onSizeChanged(w, h, oldw, oldh);
		mBitmap = Bitmap.createBitmap(w, h, Bitmap.Config.ARGB_8888);
		mCanvas = new Canvas(mBitmap);
		this.setBackgroundColor(mBackGroundColor);
		// this.onSetAlpha(mBackgroundOpacity/255);
		if (mBackGround != null) {
			this.setBackgroundDrawable(mBackGround);
		}

		try {
			reDraw(0, false);
		} catch (JSONException e) {
			// TODO Auto-generated catch block
			// e.printStackTrace();
		}
		// Camera removed for this release
		// rectLogged.set(mCanvas.getWidth() - 50, 0, mCanvas.getWidth(), 50);
	}

	@Override
	protected void onDraw(Canvas canvas) {
		canvas.drawBitmap(mBitmap, 0, 0, mBitmapPaint);
		canvas.drawPath(mPath, mPaint);
	}

	private void touch_start(float x, float y) throws JSONException {

		// If entering new items i want to prune the arraylist to where i
		// undo/redo
		jArrayList.setSize(mNewArrayListSize);
		mNumberMove = 0;

		mPaint.setXfermode(null);
		mPaint.setColor(mPaintColor);
		mPaint.setStrokeWidth(mSW);
		mPaint.setAlpha(mBrushOpacity);
		mPaint.setMaskFilter(mMaskFilter);
		mPath.reset();
		mPath.moveTo(x, y);
		mX = x;
		mY = y;

		jArray = new JSONArray();
		JSONObject jPoint = new JSONObject();
		jPoint.put("x", mX);
		jPoint.put("y", mY);
		jPoint.put("cW", mCanvas.getWidth());
		jPoint.put("cH", mCanvas.getHeight());
		jPoint.put("pC", mPaintColor);
		jPoint.put("pW", mSW);
		jPoint.put("OP", mBrushOpacity);
		jPoint.put("OB", mBackgroundOpacity);

		if (mErase == true) {
			jPoint.put("pW", mEraserWidth);
			mPaint.setStrokeWidth(mEraserWidth);
			mPaint.setXfermode(new PorterDuffXfermode(PorterDuff.Mode.CLEAR));
		}

		jPoint.put("mF", mF);
		jPoint.put("CLR", mClr);
		// Make sure user does not move forward/backward here is this is handled
		// in the redraw function
		jPoint.put("DRW", 0);
		jPoint.put("BKG", "");
		jPoint.put("BKC", mBackGroundColor);
		jArray.put(jPoint);

	}

	private void touch_move(float x, float y) throws JSONException {
		float dx = Math.abs(x - mX);
		float dy = Math.abs(y - mY);
		if (dx >= TOUCH_TOLERANCE || dy >= TOUCH_TOLERANCE) {
			/*
			 * if (mErase == true) { mPath.moveTo(x, y);
			 * mPaint.setStrokeWidth(mEraserWidth); mPaint.setXfermode(new
			 * PorterDuffXfermode(PorterDuff.Mode.CLEAR)); return; }
			 */
			mPath.quadTo(mX, mY, (x + mX) / 2, (y + mY) / 2);
			mX = x;
			mY = y;
			JSONObject jPoint = new JSONObject();
			jPoint.put("x", mX);
			jPoint.put("y", mY);
			jPoint.put("TXT", "");

			jArray.put(jPoint);
		}
	}

	private void touch_up() throws JSONException {
		mPath.lineTo(mX, mY);

		setText(mTextString, mAngle, mTextSize, mPaintColor, mTypefaceString,
				false);
		// if (mText) {
		// mImm.hideSoftInputFromWindow(mEditText.getWindowToken(), 0);
		// mView.setVisibility(View.GONE);
		// setAngle();
		// }

		// mCanvas.drawCircle(mX, mY, 100, mPaint);
		// commit the path to our offscreen
		mCanvas.drawPath(mPath, mPaint);

		// if (mErase == false) {
		JSONObject jPoint = new JSONObject();
		jPoint.put("x", mX);
		jPoint.put("y", mY);
		if (mText) {
			jPoint.put("TF", mTypefaceString);
			jPoint.put("TS", mTextSize);
			jPoint.put("TXT", mTextString);
			jPoint.put("ANG", mAngle);
			jPoint.put("ERA", mErase);
		} else {
			jPoint.put("TF", null);
			jPoint.put("TS", "");
			jPoint.put("TXT", "");
			jPoint.put("ANG", 0);
			jPoint.put("ERA", mErase);
		}
		jArray.put(jPoint);

		// Add the array to bottom of list
		jArrayList.add(jArray);
		mNewArrayListSize = jArrayList.size();

		if (mNetworkOn) {
			Token mMessageToken = new Token();
			// Send points to friends
			String chatString = mMessageToken.createMessagetoFriendsToken(
					mMemberid, jArray.toString(), true);
			MainActivity.sendMessage(chatString);
		}
		// }
		// Lets save the path to our array of paths
		// kill this so we don't double draw
		mPath.reset();
		mTextString = "";
		mText = false;
		mDRW = 0;
		// mView.setVisibility(View.GONE);
	}

	public void rotateText(int angle) {
		mAngle = angle;
	}

	public void reDraw(int aDirection, boolean aSend) throws JSONException {
		// float mX = 0, mY = 0;
		mRedraw = true;

		mDRW = 0;
		int mSize = jArrayList.size();
		clear();

		mNumberMove += aDirection;
		if (mNumberMove > mSize) {
			mNumberMove = mSize;
		}

		if ((mSize - mNumberMove) > mSize) {
			mNumberMove++;
		}

		mNewArrayListSize = mSize - mNumberMove;

		for (int j = 0; j < mNewArrayListSize; j++) {
			JSONArray jsonArray = jArrayList.elementAt(j);
			reDrawOne(jsonArray, false);

		}
		// Tell friends to undo/redo
		if (aSend && mNetworkOn) {

			// Tell Friends to redraw as well
			jArray = new JSONArray();
			JSONObject jDraw = new JSONObject();
			try {
				jDraw.put("DRW", aDirection);
				jDraw.put("CLR", false);
				jDraw.put("BKG", "");
				jDraw.put("BKC", "");
			} catch (JSONException e) {
				// TODO Auto-generated catch block
				// e.printStackTrace();
			}
			jArray.put(jDraw);

			Token mMessageToken = new Token();
			// Send info to friends
			String chatString = mMessageToken.createMessagetoFriendsToken(
					mMemberid, jArray.toString(), true);
			MainActivity.sendMessage(chatString);
		}
		mRedraw = false;
		mText = false;
		return;
	}

	public String getLatestDrawing() {
		return jArrayList.toString();
	}

	public boolean chatDraw(String aMessage) throws JSONException {
		// Dont draw if network is not on
		if (!mNetworkOn) {
			return mRedraw;
		}
		Token chatToken = new Token();
		chatToken.createToken(aMessage);

		aMessage = chatToken.getString("response");
		if (aMessage==null){
			aMessage = chatToken.getString("message");}
		JSONArray jsonArray = new JSONArray(aMessage);
		// jsonArray.parseArray(aMessage);
		if (aMessage.startsWith("[[")) {
			jsonArray = new JSONArray(aMessage);
			// jsonArray.parseArray(aMessage);
			if (jsonArray.length() > 0) {
				reDraw(jsonArray);
				return mRedraw;
			}
		}
		return reDrawOne(jsonArray, true);
	}

	public void reDraw(JSONArray jsonArrayTemp) throws JSONException {
		mNewArrayListSize = 0;
		jArrayList.setSize(mNewArrayListSize);
		int mSize = jsonArrayTemp.length();

		for (int j = 0; j < mSize; j++) {
			jArrayList.add(jsonArrayTemp.getJSONArray(j));
		}
		reDraw(0, false);
	}

	private boolean reDrawOne(JSONArray jsonArray, boolean addtoArrayList)
			throws JSONException {
		mX = 0;
		mY = 0;
		int mDrwColor = 0;
		String mDrwTF = "";
		for (int i = 0; i < jsonArray.length(); i++) {
			JSONObject jsonPoints = jsonArray.getJSONObject(i);

			if (i == 0) {
				if (jsonPoints.optBoolean("CLR")) {
					// Dont want to clear background as it is in the first array
					mNumberMove = 0;
					mNewArrayListSize = 1;
					jArrayList.setSize(mNewArrayListSize);
					// Redraw but do not send
					reDraw(0, false);
					mSlideShow = false;
					if (mTimer != null) {
						mTimer.purge();
						mTimer.cancel();
					}
					// stopSlideShow(false);

					invalidate();
					return mRedraw;
				}
				mDRW = jsonPoints.getInt("DRW");
				if (mDRW != 0) {
					// reDraw back or forward dont send
					reDraw(mDRW, false);
					invalidate();
					mDRW = 0;
					return mRedraw;

				}
				mPaint.setXfermode(null);
				int mOB = jsonPoints.optInt("OB");
				if ((mOB != -1) && (mOB != 0)) {
					mBackgroundOpacity = jsonPoints.getInt("OB");
					mPaint.setAlpha(mOB);
					addtoArrayList = false;

				}
				int mBKC = jsonPoints.optInt("BKC");
				if (mBKC != -1 && mBKC != 0) {
					mBackGroundColor = mBKC;
					mBackGroundString = "";
					mBackGround = null;
					addtoArrayList = false;
					setBackGround("", false);
					this.setBackgroundColor(mBackGroundColor);
				}
				mBackGroundString = jsonPoints.optString("BKG");
				if (mBackGroundString.length() > 500) {
					addtoArrayList = false;
					mBackGroundColor = -1;
					setBackGround(mBackGroundString, false);
					Bitmap bm = getBitmapFromString(mBackGroundString);
					restorefromBitmap(bm);
				}
				if (jsonPoints.optInt("cW") != 0) {

					mScaleW = (float) mCanvas.getWidth()
							/ jsonPoints.getInt("cW");
					mScaleH = (float) mCanvas.getHeight()
							/ jsonPoints.getInt("cH");
					mDrwColor = jsonPoints.getInt("pC");

					mPaint.setColor(jsonPoints.getInt("pC"));
					mPaint.setStrokeWidth(jsonPoints.getLong("pW"));
					mPaint.setAlpha(jsonPoints.optInt("OP"));
					mPaint.setMaskFilter(getMaskFilter(jsonPoints.getInt("mF")));
					if (jsonPoints.getLong("x") == 0) {
						return mRedraw;
					}
					mX = jsonPoints.getLong("x") * mScaleW;
					mY = jsonPoints.getLong("y") * mScaleH;
					mPath.reset();
					mPath.moveTo(mX, mY);
				}
				continue;
			}
			// Just test if erase is being sent properly
			boolean temperase = jsonPoints.optBoolean("ERA");
			if (temperase) {
				mPaint.setXfermode(new PorterDuffXfermode(PorterDuff.Mode.CLEAR));
			} else {
				mPaint.setXfermode(null);
			}

			float x = jsonPoints.getLong("x") * mScaleW;
			float y = jsonPoints.getLong("y") * mScaleH;
			mTextString = jsonPoints.getString("TXT");
			if (mTextString.length() > 0) {
				mPaint.setTextSize(jsonPoints.getInt("TS"));
				mAngle = jsonPoints.getInt("ANG");
				int ts = jsonPoints.getInt("TS");
				mDrwTF = jsonPoints.getString("TF");
				setText(mTextString, mAngle, ts, mDrwColor, mDrwTF, true);
				mTextString = "";
				// mCanvas.drawText(mTextString, mX, mY, mPaint);
			} else {
				mPath.quadTo(mX, mY, (x + mX) / 2, (y + mY) / 2);
				mCanvas.drawPath(mPath, mPaint);
			}
			mX = x;
			mY = y;

		}
		if (addtoArrayList) {
			jArrayList.setSize(mNewArrayListSize);
			mNumberMove = 0;
			jArrayList.add(jsonArray);
			mNewArrayListSize = jArrayList.size();
		}
		invalidate();

		return mRedraw;
	}

	public void setTextView(EditText v, View d, InputMethodManager i) {
		mEditText = v;
		mView = d;
		mImm = i;
	}

	public void setTypeFace(Typeface aTypeface, String aTypefaceString) {
		mTypeface = mPaint.setTypeface(aTypeface);
		mTypefaceString = aTypefaceString;
	}

	public void setText(String text, int angle, int textsize, int textcolor,
			String typeface, boolean redraw) {
		if (!redraw) {
			mTextString = mEditText.getText().toString();
			text = mTextString;
			mImm.hideSoftInputFromWindow(mEditText.getWindowToken(), 0);
		}
		// text=mTextString;
		if (text == null || text.length() < 1) {
			return;
		}

		Rect rect = new Rect();
		TextPaint mTextPaint = new TextPaint();
		mTextPaint.setAntiAlias(true);
		mTextPaint.setTextSize(textsize);
		mTextPaint.setColor(textcolor);
		mTextPaint.setStyle(Paint.Style.FILL);
		mTextPaint.setTextAlign(Paint.Align.LEFT);
		Typeface t = Typeface.createFromAsset(mContext.getAssets(),
				mTypeFacePath + typeface);
		mTextPaint.setTypeface(t);
		mTextPaint.getTextBounds(text, 0, text.length(), rect);

		int mBreakWidth = rect.width();
		int mLayoutWidth = mCanvas.getWidth() - (int) mX - 1;
		if (mBreakWidth > mLayoutWidth) {
			mBreakWidth = mLayoutWidth;
		}

		mCanvas.save();

		mCanvas.rotate(angle, mX + rect.exactCenterX(),
				mY + rect.exactCenterY());

		mCanvas.translate(mX, mY);
		mTextPaint.breakText(text, true, mBreakWidth, null);

		StaticLayout layoutText = new StaticLayout(text, mTextPaint,
				mLayoutWidth, Layout.Alignment.ALIGN_NORMAL, 1f, 0f, false);

		layoutText.draw(mCanvas);
		mCanvas.restore();
		if (text != null) {
			mEditText.setText("");
		}

		mText = true;
		mErase = false;
		// mPaint.setXfermode(null);

	}

	public HashSet getColorSampleList() {
		return mColorSampleList;
	}

	@Override
	public boolean onTouch(View view, MotionEvent event) {
		float x = event.getX();
		float y = event.getY();
		/*
		 * if (rectSlideShow.contains((int) x, (int) y)) {
		 * mPaint.setStyle(Paint.Style.FILL);
		 * mCanvas.drawCircle(rectSlideShow.centerX(), rectSlideShow.centerY(),
		 * 50.0f, mPaint); if(mPause){ pauseSlideShow(false); }else{
		 * pauseSlideShow(true); } mPaint.setStyle(Paint.Style.STROKE);
		 * invalidate(); return true; }
		 */
		/*
		 * if (rectLogged.contains((int) x, (int) y)) {
		 * mPaint.setStyle(Paint.Style.FILL); mCanvas.drawRect(rectLogged,
		 * mPaint); mPaint.setStyle(Paint.Style.STROKE); invalidate();
		 * mColorSample = true; return true; }
		 */
		if (mColorSample) {
			// Bitmap bm;
			// bm = this.getDrawingCache();
			int pixelcolor = mColorSampleBitmap.getPixel((int) x, (int) y);
			if (!mColorSampleList.contains(pixelcolor)) {
				mColorSampleList.add(pixelcolor);
			}
			mPaint.setColor(pixelcolor);
			mCanvas.drawRect(rectLogged, mPaint);
			// mCanvas.drawCircle(rectLogged.left+10, 10, 10, mPaint);
			invalidate();
		} else {
			/*
			 * Remove camera functionality for now if
			 * (rectSlideShow.contains((int) x, (int) y)) { Intent newIntent =
			 * new Intent(mContext, PictureDemo.class);
			 * mContext.startActivity(newIntent); invalidate(); return true; }
			 */
			try {
				switch (event.getAction()) {

				case MotionEvent.ACTION_DOWN:

					touch_start(x, y);
					invalidate();
					break;
				case MotionEvent.ACTION_MOVE:
					touch_move(x, y);
					invalidate();
					break;
				case MotionEvent.ACTION_UP:
					touch_up();
					invalidate();
					break;

				}
			} catch (JSONException e) {
				// TODO Auto-generated catch block
				// e.printStackTrace();
			}
		}
		return true;
	}

	public void setColor(int aColor) {
		mPaintColor = aColor;
		mErase = false;
	}

	public boolean erase(boolean erase) {
		// If you click on erase button again it will turn erase off
		mErase = erase;
		return mErase;
	}

	public boolean setSampleStatus(boolean samplestatus) {
		// Turn Sample Mode On or off
		mColorSample = samplestatus;

		if (samplestatus) {
			rectLogged.set(mCanvas.getWidth() - 20, 0, mCanvas.getWidth(), 20);
			this.setDrawingCacheEnabled(true);
			mColorSampleBitmap = this.getDrawingCache();
			mPaint.setStyle(Paint.Style.FILL);
		} else {
			rectLogged.setEmpty();
			this.setDrawingCacheEnabled(false);
			mPaint.setStyle(Paint.Style.STROKE);
		}
		return mColorSample;
	}

	/*
	 * public void setSlideShowViewGroup(ViewGroup viewGroup){ slideshowButtons
	 * = viewGroup; }
	 */
	public void clearall() throws JSONException {
		stopSlideShow(false);
		// slideshowButtons.setVisibility(View.GONE);

		mNewArrayListSize = 1;
		mNumberMove = 0;
		jArrayList.setSize(mNewArrayListSize);
		// clear();
		reDraw(0, false);
		// invalidate();
		// Remove Camera for now
		// mCanvas.drawBitmap(bitmapPicture, rectSlideShow.left,
		// rectSlideShow.top, mBitmapPaint);

		// If no network dont bother
		if (!mNetworkOn) {
			return;
		}
		// Tell Friends to clear as well
		jArray = new JSONArray();
		JSONObject jClearAll = new JSONObject();
		try {
			jClearAll.put("CLR", true);
		} catch (JSONException e) {
			// TODO Nothing
		}
		jArray.put(jClearAll);

		Token mMessageToken = new Token();
		// Send info to friends
		String chatString = mMessageToken.createMessagetoFriendsToken(
				mMemberid, jArray.toString(), true);
		MainActivity.sendMessage(chatString);

	}

	// Notice difference in spelling...not inherited
	public void setBackGroundColor(int aColor) {

		mBackGroundColor = aColor;
		if (mSlideShow) {
			stopSlideShow(false);
			// slideshowButtons.setVisibility(View.GONE);
		}

		if (Build.VERSION.SDK_INT > 10) {
			if (mBackgroundOpacity > 0) {
				int alpha = mBackgroundOpacity / 255;
				this.onSetAlpha(alpha);
			}
		}

		this.setBackgroundColor(aColor);

		setBackGround("", true);
		mBackGround = null;
		mBackGroundString = "";
		mErase = false;
		mRedraw = false;
	}

	private void clear() {
		mBitmap = Bitmap.createBitmap(mCanvas.getWidth(), mCanvas.getHeight(),
				Bitmap.Config.ARGB_8888);
		mCanvas = new Canvas(mBitmap);
		mErase = false;
	}

	public void setStrokeWidth(float aWidth) {
		mSW = aWidth;
		mErase = false;
	}

	public void setBrushOpacity(int opacity) {
		mBrushOpacity = opacity;
		mErase = false;
	}

	public void setBackgroundOpacity(int opacity) {
		mBackgroundOpacity = opacity;
		mErase = false;
	}

	public void setEraserWidth(int aWidth) {
		mEraserWidth = aWidth;
		mErase = false;
	}

	public void setTextSize(int aSize) {
		mTextSize = aSize;
		mText = false;
	}

	public File save(String aFilename) {
		mErase = false;
		Bitmap mBitmaptoSave;
		// Save Bitmap to File
		FileOutputStream fos = null;
		File filename = null;
		this.setDrawingCacheEnabled(true);
		try {
			boolean mSuccess = false;
			if (!folder.exists()) {
				mSuccess = folder.mkdir();
			}

			filename = new File(folder + "/" + aFilename + ".png");

			fos = new FileOutputStream(filename);
			mBitmaptoSave = this.getDrawingCache(); // This allows background to
													// be saved also

			mBitmaptoSave.compress(Bitmap.CompressFormat.PNG, 100, fos);

			fos.flush();
			fos.close();
			fos = null;
		} catch (IOException e) {
			e.printStackTrace();
		}
		this.setDrawingCacheEnabled(false); // This clears the cache for next
											// save
		return filename;

	}

	public void restorefromBitmap(Bitmap aBitmap) {
		// Restore Bitmap to background

		mBackGround = new BitmapDrawable(aBitmap);
		mBackGroundString = getStringFromBitmap(aBitmap);
		this.setBackgroundDrawable(mBackGround);
		if (Build.VERSION.SDK_INT > 10) {
			if (mBackgroundOpacity > 0) {
				int alpha = mBackgroundOpacity / 255;
				this.onSetAlpha(alpha);
			}
		}
		invalidate();
	}

	public int restore(String aFileName, boolean slideshow) {
		// Restore Bitmap to background
		int mReturn = -1;
		mSlideShow = slideshow;

		File filename = new File(aFileName);
		Bitmap bm = decodeFile(filename, 0);
		if (bm == null) {
			return mReturn;
		}
		restorefromBitmap(bm);
		bm = null;
		// Send Message to Friends
		// if (mNetworkOn) {
		setBackGround(mBackGroundString, true);
		// }
		mRedraw = false;
		return SUCCESS;
	}

	public void stopSlideShow(boolean slideshow) {
		if (!isSlideShowStarted()) {
			return;
		}
		mSlideShow = slideshow;

		// Paint paint = new Paint();
		if (mTimer == null) {
			return;
		}
		while (mTimer != null) {
			mTimer.purge();
			mTimer.cancel();
			mTimer = null;
		}
		/*
		 * rectSlideShow.set(mCanvas.getWidth() / 2 - 100, mCanvas.getHeight() -
		 * 100, mCanvas.getWidth() / 2 + 100, mCanvas.getHeight());
		 * 
		 * if (slideshow) {
		 * 
		 * paint.setColor(getResources().getColor(R.color.green));
		 * paint.setStyle(Paint.Style.FILL);
		 * mCanvas.drawCircle(rectSlideShow.centerX(), rectSlideShow.centerY(),
		 * 50.0f, paint); mCanvas.drawBitmap(bitmapPlay, rectSlideShow.centerX()
		 * - (bitmapPlay.getWidth() / 2), rectSlideShow.centerY() -
		 * (bitmapPlay.getHeight() / 2), mBitmapPaint); } else {
		 * 
		 * paint.setStyle(Paint.Style.FILL); paint.setColor(mBackGroundColor);
		 * mCanvas.drawCircle(rectSlideShow.centerX(), rectSlideShow.centerY(),
		 * 50.0f, paint); rectSlideShow.setEmpty(); mPause = false; mSlides =
		 * null; }
		 */
	}

	public void freememory() {
		Runtime freememory = Runtime.getRuntime();
		freememory.gc();
	}

	public void backOneSlide() {
		if (!mPause) {
			pauseSlideShow(true);
		}

		if (mCount > 0) {
			mCount -= 1;
		} else {
			mCount = mSlides.length - 1;
		}
		restore(mSlides[mCount], mSlideShow);

	}

	public void forwardOneSlide() {
		if (!mPause) {
			pauseSlideShow(true);
		}
		// Loop back to first slide if
		if (mCount >= mSlides.length - 1) {
			mCount = 0;
		} else {
			mCount += 1;
		}
		restore(mSlides[mCount], mSlideShow);
	}

	public boolean isSlideShowStarted() {
		return mSlideShow;
	}

	public void pauseSlideShow(boolean pause) {
		if (pause) {
			stopSlideShow(true);
			// mPause=pause;

		} else {
			// mPause=false;
			startSlideShow(mSlides, mCount, mInterval);

		}
		mPause = pause;
	}

	public void startSlideShow(final String[] slides, int countToStartAt,
			final long interval) {
		if (isSlideShowStarted()) {
			return;
		}

		if (slides == null) {
			return;
		}
		mTimer = new Timer();
		final Handler mHandler = new Handler();
		final int cnt = slides.length;
		mInterval = interval;
		mCount = countToStartAt;
		mSlides = slides;
		mSlideShow = true;

		mTimer.scheduleAtFixedRate(new TimerTask() {

			public void run() {

				mHandler.post(new Runnable() {

					@Override
					public void run() {
						// if(!mSlideShow){return;}
						restore(slides[mCount], mSlideShow);
						if (mCount == cnt - 1) {
							mCount = 0;
						} else {
							mCount++;
						}

					}
				});

			}

		}, 0, interval);
		// slideshowButtons.setVisibility(View.VISIBLE);
	}

	public void startSlideShow2(final String[] slides, final long interval) {
		mInterval = interval;
		final int cnt = slides.length;
		if (cnt == 0) {
			Thread.currentThread().interrupt();
			return;
		}
		mCount = 0;
		freememory();
		final Handler mHandler = new Handler();
		mSlideShow = true;

		Thread imageThread = new Thread() {

			@Override
			public void run() {

				while (mSlideShow) {
					mHandler.post(new Runnable() {

						@Override
						public void run() {
							restore(slides[mCount], mSlideShow);
							if (mCount == cnt - 1) {
								mCount = 0;
							} else {
								mCount++;
							}

						}
					});
					try {
						sleep(interval);
					} catch (InterruptedException e) {
						mSlideShow = false;
					}
				}
			}
		};

		imageThread.start();
	}

	public int displayUserBitmap(String aFileName, int left, int top) {
		// Restore Bitmap to background
		int mReturn = -1;
		freememory();

		File filename = new File(aFileName);
		Bitmap bm = decodeFile(filename, 0);
		// int w = mCanvas.getWidth();
		bm = bm.createScaledBitmap(bm, 50, 50, false);
		if (bm == null) {
			return mReturn;
		}
		// rectLogged.set(mCanvas.getWidth() - 50, 0, mCanvas.getWidth(), 50);
		// mCanvas.drawBitmap(bm, rectLogged.left, rectLogged.top,
		// mBitmapPaint);

		// Send Message to Friends
		// if (mNetworkOn) {
		// setBackGround(mBackGroundString, true);
		// }
		mRedraw = false;
		return SUCCESS;
	}

	private void setBackGround(String aBitmapString, boolean aSend) {
		// Tell Friends to redraw as well
		JSONArray jArray = new JSONArray();
		JSONObject jDraw = new JSONObject();
		try {
			jDraw.put("DRW", 0);
			jDraw.put("CLR", false);
			jDraw.put("BKC", mBackGroundColor);
			jDraw.put("OB", mBackgroundOpacity);

			if (aBitmapString.length() < 500) {
				aBitmapString = "";
			}
			jDraw.put("BKG", aBitmapString);

		} catch (JSONException e) {
			// e.printStackTrace();
		}
		jArray.put(jDraw);
		if (jArrayList.size() == 0) {
			jArrayList.add(0, jArray);
		} else {
			jArrayList.set(0, jArray);
		}
		if (!mNetworkOn || !aSend) {
			return;
		}
		Token mMessageToken = new Token();
		// Send info to friends
		String chatString = mMessageToken.createMessagetoFriendsToken(
				mMemberid, jArray.toString(), true);
		MainActivity.sendMessage(chatString);

	}

	public Bitmap decodeFile(File f, int imagesize) {
		if (imagesize == 0) {
			imagesize = IMAGE_MAX_SIZE;
		}
		Bitmap b = null;
		try {
			// Decode image size
			BitmapFactory.Options o = new BitmapFactory.Options();
			o.inJustDecodeBounds = true;

			FileInputStream fis = new FileInputStream(f);
			BitmapFactory.decodeStream(fis, null, o);
			fis.close();

			int scale = 1;

			if (o.outHeight > imagesize || o.outWidth > imagesize) {
				scale = (int) Math.pow(
						2.0,
						(int) Math.round(Math.log(imagesize
								/ (double) Math.max(o.outHeight, o.outWidth))
								/ Math.log(0.5)));
			}

			// Decode with inSampleSize
			BitmapFactory.Options o2 = new BitmapFactory.Options();
			o2.inSampleSize = scale;
			fis = new FileInputStream(f);
			b = BitmapFactory.decodeStream(fis, null, o2);
			fis.close();
			freememory();
		} catch (IOException e) {
		}
		return b;
	}

	private String getStringFromBitmap(Bitmap bitmapPicture) {
		/*
		 * This functions converts Bitmap picture to a string which can be
		 * JSONified.
		 */
		final int COMPRESSION_QUALITY = 100;
		String encodedImage = null;
		ByteArrayOutputStream byteArrayBitmapStream = new ByteArrayOutputStream();
		bitmapPicture.compress(Bitmap.CompressFormat.PNG, COMPRESSION_QUALITY,
				byteArrayBitmapStream);
		byte[] b = byteArrayBitmapStream.toByteArray();
		encodedImage = Base64.encodeToString(b, false);
		return encodedImage;
	}

	public Bitmap getBitmapFromString(String jsonString) {
		/*
		 * This Function converts the String back to Bitmap
		 */
		byte[] decodedString = Base64.decode(jsonString);
		Bitmap decodedByte = BitmapFactory.decodeByteArray(decodedString, 0,
				decodedString.length);
		return decodedByte;
	}

	public String cleanUp() {
		try {
			mNetworkOn = false;
			this.finalize();
		} catch (Throwable e) {
			return e.getMessage();
		}
		return "Closed";

	}

}